%{
#include <stdio.h>
#include <iostream>
#include <string.h>
#include <fstream>
#include "KML.hpp"
#include "ast.hpp"
#include "generator.hpp"

#define DEBUG_PARSER 0

int yywrap();
int yylex();
void yyerror(const char *str);

NodePtr program(0);
NodePtr baseLayer(0);
NodePtr overlayLayer(0);
%}

%token XML_VERSION OPEN_KML CLOSE_KML OPEN_DOCUMENT CLOSE_DOCUMENT OPEN_PLACEMARK CLOSE_PLACEMARK OPEN_DESCRIPTION CLOSE_DESCRIPTION OPEN_LINESTRING
CLOSE_LINESTRING OPEN_NAME CLOSE_NAME OPEN OPEN_POINT CLOSE_POINT OPEN_COORDINATE CLOSE_COORDINATE OPEN_POLYGON CLOSE_POLYGON OPEN_OUTER_BOUNDARY
CLOSE_OUTER_BOUNDARY OPEN_INNER_BOUNDARY CLOSE_INNER_BOUNDARY OPEN_LINEAR_RING CLOSE_LINEAR_RING COMMA_DELIMETER STRING_LITERAL NUMBER_LITERAL WS EOL

%%
program:
kml
{
#if DEBUG_PARSER == 1
  std::cout << "program : kml=" << $1 << std::endl;
#endif
  program = $1;
}
; /*program*/

optionalws:
/* empty */
|
optionalws WS
|
optionalws EOL
; /* optionalws */

kml:
optionalws OPEN_KML document CLOSE_KML optionalws
{
  #if DEBUG_PARSER == 1
    std::cout << "kml: document=" << $3 << std::endl;
  #endif
  $$ = NodePtr(new KMLNode($3));
}
; /*kml*/

document:
/* empty */
{
  $$ = NodePtr(new DocumentNode());
}
|
optionalws OPEN_DOCUMENT major_tag CLOSE_DOCUMENT optionalws
{
  #if DEBUG_PARSER == 1
    std::cout << "document: major_tag=" << $3 << std::endl;
  #endif
  $$ = $3;
}
; /*document*/


major_tag:
/* empty */
{
  #if DEBUG_PARSER == 1
    std::cout << "major_tag: empty" << std::endl;
  #endif
  $$ = NodePtr(new DocumentNode());
}
|
major_tag placemarker
{
  #if DEBUG_PARSER == 1
    std::cout << "major_tag: major_tag=" << $1 << " minor_tag=" << $2 << std::endl;
  #endif
  $$=$1;
  $$->children.push_back($2);
}
|
major_tag linestring
{
  #if DEBUG_PARSER == 1
    std::cout << "major_tag: major_tag=" << $1 << " minor_tag=" << $2 << std::endl;
  #endif
  $$=$1;
  $$->children.push_back($2);
}
|
major_tag polygon
{
  #if DEBUG_PARSER == 1
    std::cout << "major_tag: major_tag=" << $1 << " minor_tag=" << $2 << std::endl;
  #endif
  $$=$1;
  $$->children.push_back($2);
}
; /*major_tag*/

polygon:
optionalws OPEN_POLYGON outer_boundary CLOSE_POLYGON optionalws
{
  $$ = NodePtr(new PolygonNode($3));
}
; /*polygon*/

outer_boundary:
optionalws OPEN_OUTER_BOUNDARY linear_ring CLOSE_OUTER_BOUNDARY optionalws
{
  $$ = NodePtr(new OuterBoundaryNode($3));
}
; /*outer_boundary*/

inner_boundaries:
/* empty */
{
  $$ = NodePtr(new InnerBoundariesNode());
}
|
inner_boundaries inner_boundary
{
  $$ = $1;
  $$->children.push_back($2);
}
; /*outer_boundary*/

inner_boundary:
optionalws OPEN_INNER_BOUNDARY linear_ring CLOSE_INNER_BOUNDARY optionalws
{
  $$ = NodePtr(new InnerBoundaryNode($3));
}
; /*inner_boundary*/

linear_ring:
optionalws OPEN_LINEAR_RING optionalws OPEN_COORDINATE coordinates CLOSE_COORDINATE optionalws CLOSE_LINEAR_RING optionalws
{
  $$ = NodePtr(new LinearRingNode($5));
}
; /*linear_ring*/


placemarker:
optionalws OPEN_PLACEMARK descriptors CLOSE_PLACEMARK optionalws
{
  $$ = NodePtr(new PlacemarkerNode($3));
}
; /*placemarker*/

descriptors:
/* empty */
{
  #if DEBUG_PARSER == 1
    std::cout << "descriptor: empty" << std::endl;
  #endif
  $$ = NodePtr(new DescriptorsNode());
}
|
descriptors minor_tag
{
  #if DEBUG_PARSER == 1
    std::cout << "descriptor: descriptor=" << $1 << " minor_tag=" << $2 << std::endl;
  #endif
  $$ = $1;
  $$->children.push_back($2);
}
; /*descriptor*/

linestring:
optionalws OPEN_LINESTRING optionalws OPEN_COORDINATE coordinates CLOSE_COORDINATE optionalws CLOSE_LINESTRING optionalws
{
  #if DEBUG_PARSER == 1
    std::cout << "linestring: coordinates =" << $5 << std::endl;
  #endif
  $$ = NodePtr(new LineStringNode($5));
  //$$->children.push_back($5);
}
; /*linestring*/

minor_tag:
name_tag
{
  #if DEBUG_PARSER == 1
    std::cout << "minor_tag: nametag=" << $1 << std::endl;  
  #endif
  $$ = $1;
}
|
description_tag
{
  #if DEBUG_PARSER == 1
    std::cout << "minor_tag: description_tag=" << $1 << std::endl;
  #endif
  $$ = $1;
}
|
point_tag
{
  #if DEBUG_PARSER == 1
    std::cout << "minor_tag: description_tag=" << $1 << std::endl;
  #endif
  $$ = $1;
}
; /*minor_tag*/

name_tag:
optionalws OPEN_NAME optionalws STRING_LITERAL optionalws CLOSE_NAME optionalws
{
  #if DEBUG_PARSER == 1
    std::cout << "name_tag: string_literal=" << $4 << std::endl;
  #endif
  $$ = NodePtr(new NameNode($4));
}
; /*name tag*/

description_tag:
optionalws OPEN_DESCRIPTION optionalws STRING_LITERAL optionalws CLOSE_DESCRIPTION optionalws
{
  #if DEBUG_PARSER == 1
    std::cout << "description_tag: string_literal=" << $4 << std::endl;
  #endif
  $$ = NodePtr(new DescriptionNode($4));
}
; /*description tag*/

point_tag:
optionalws OPEN_POINT optionalws coordinate optionalws CLOSE_POINT optionalws
{
  #if DEBUG_PARSER == 1
    std::cout << "point_tag: coordinate=" << $4 << std::endl;
  #endif
  $$ = NodePtr(new PointNode($4));
}
; /*point_tag*/

coordinates:
/*empty*/
{
  #if DEBUG_PARSER == 1
    std::cout << "coordinates: empty" << std::endl;
  #endif
  $$ = NodePtr(new CoordinateListNode());
}
|
coordinates singlecor
{
  #if DEBUG_PARSER == 1
    std::cout << "coordinates = " << $1 << " singlecor = " << $2 << std::endl;
  #endif
  $$ = $1;
  $$->children.push_back($2);
}
; /*coordinates*/


singlecor:
optionalws NUMBER_LITERAL COMMA_DELIMETER NUMBER_LITERAL COMMA_DELIMETER NUMBER_LITERAL optionalws
{
  #if DEBUG_PARSER == 1
    std::cout << "singlecor(" << $2 << "," << $4 << "," << $6 << ")" << std::endl;
  #endif
  $$ = NodePtr(new CoordinateNode($2,$4,$6));
}
; 

coordinate:
optionalws NUMBER_LITERAL COMMA_DELIMETER NUMBER_LITERAL COMMA_DELIMETER NUMBER_LITERAL optionalws
{
  #if DEBUG_PARSER == 1
    std::cout << "coordinate: numberLiteral1=" << $2 << "numberLiteral2=" << $4 << "numberLiteral3=" << $6 << std::endl;
  #endif
  $$ = NodePtr(new CoordinateNode($2,$4,$6));
}
|
optionalws OPEN_COORDINATE NUMBER_LITERAL COMMA_DELIMETER NUMBER_LITERAL COMMA_DELIMETER NUMBER_LITERAL CLOSE_COORDINATE optionalws
{
  #if DEBUG_PARSER == 1
    std::cout << "coordinate: numberLiteral1=" << $3 << "numberLiteral2=" << $5 << "numberLiteral3=" << $7 << std::endl;
  #endif
  $$ = NodePtr(new CoordinateNode($3,$5,$7));
}
; /*coordinate*/

%%

int yywrap()
{
  return 1;
} 

void yyerror(const char *str)
{
  fprintf(stderr,"error: %s while parsing\n",str);
}

void scanCLAs(int argc, char *argv[], std::string &baseFile, std::string &overlayFile, std::string &outputFile){
  for(int i = 1; i < argc; ++i){
    //Find the 'base file' which is the file that we are extracting from
    if(strncmp(argv[i], "-bf", 3) == 0){
      baseFile = argv[i+1];
    }
    //Find the 'overlay file' which is the file that we are using to get the subset from
    if(strncmp(argv[i], "-of",3) == 0){      
      overlayFile = argv[i+1];
    }
    //Find the optional output file that the results are to be written to
    if(strncmp(argv[i], "-out",4) == 0){
      outputFile = argv[i+1];
    }
  }
}

void displayHelp(){
  std::cout << std::endl;
  std::cout << "You must supply at least two arguments to use this compiler:" << std::endl;
  std::cout << "1) use -bf to specify what kml/skml file should be used as the base file" << std::endl;
  std::cout << "2) use -of to specify what kml/skml file should be used as the overlay file" << std::endl;
  std::cout << std::endl << "*optional* -out to specify what file the output should be written to (default is console)" << std::endl;
  std::cout << std::endl;
}

int main(int argc, char *argv[])
{
  if(argc < 5){
    displayHelp();
    return 0;
  }
  std::string baseFileName = "";
  std::string overlayFileName = "";
  std::string outputFileName = "";
  bool outputSpecified = false;
  std::ofstream outf;

  //scan for command line arguments
  scanCLAs(argc,argv,baseFileName, overlayFileName, outputFileName);

  if(outputFileName != ""){
    outf.open(outputFileName);
    outputSpecified = true;
  }

  yyin = fopen(baseFileName.c_str(),"r");

//Parse the base layer
  yyparse();
  if (!! program) {
    //program->print(std::cout);
    baseLayer = program;
    //GeneratorPtr gen = generator(baseLayer);
    //gen->generate(std::cout);
  } else {
    std::cout << "syntax error. The base layer was null" << std::endl;
  }

  yyin = fopen(overlayFileName.c_str(),"r");

//Parse the overlay layer
  yyparse();
  if (!! program) {
    //program->print(std::cout);
    overlayLayer = program;
    //GeneratorPtr gen = generator(overlayLayer);
    //gen->generate(std::cout);
    GeneratorPtr ovGen = generator(baseLayer,overlayLayer);
    if(outputSpecified)
      ovGen->generate(outf);    
    else
      ovGen->generate(std::cout);    
  } else {
    std::cout << "syntax error. The overlay layer was null" << std::endl;
  }
  if(outputSpecified)
    outf.close();
    

  return 0;
} 